{"meta":{"title":"SanW","subtitle":"SanWCoder webBlog","description":null,"author":"SanWCoder","url":"http://sanwcoder.github.io"},"pages":[{"title":"","date":"2018-04-10T03:50:23.000Z","updated":"2018-04-10T03:50:23.000Z","comments":true,"path":"404.html","permalink":"http://sanwcoder.github.io/404.html","excerpt":"","text":"404 *{margin:0;padding:0;outline:none;font-family:\\5FAE\\8F6F\\96C5\\9ED1,宋体;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;-khtml-user-select:none;user-select:none;cursor:default;font-weight:lighter;} .center{margin:0 auto;} .whole{width:100%;height:100%;line-height:100%;position:fixed;bottom:0;left:0;z-index:-1000;overflow:hidden;} .whole img{width:100%;height:100%;} .mask{width:100%;height:100%;position:absolute;top:0;left:0;background:#000;opacity:0.6;filter:alpha(opacity=60);} .b{width:100%;text-align:center;height:400px;position:absolute;top:50%;margin-top:-230px}.a{width:150px;height:50px;margin-top:30px}.a a{display:block;float:left;width:150px;height:50px;background:#fff;text-align:center;line-height:50px;font-size:18px;border-radius:25px;color:#333}.a a:hover{color:#000;box-shadow:#fff 0 0 20px} p{color:#fff;margin-top:40px;font-size:24px;} #num{margin:0 5px;font-weight:bold;} var num=4; function redirect(){ num--; document.getElementById(\"num\").innerHTML=num; if(num"},{"title":"Archives","date":"2016-08-16T07:00:24.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"archives/index.html","permalink":"http://sanwcoder.github.io/archives/index.html","excerpt":"","text":""},{"title":"","date":"2015-08-16T06:58:08.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"about/index.html","permalink":"http://sanwcoder.github.io/about/index.html","excerpt":"HipaperA fashional newspaper, blog theme for Hexo. ☞ Preview Demo | 查看中文使用文档","text":"HipaperA fashional newspaper, blog theme for Hexo. ☞ Preview Demo | 查看中文使用文档 Installation Get it from GitHub 1$ git clone https://github.com/iTimeTraveler/hexo-theme-hipaper.git themes/hipaper Enable Modify theme setting in _config.yml to hipaper. 1234# Extensions## Plugins: http://hexo.io/plugins/## Themes: http://hexo.io/themes/theme: hipaper Update 12$ cd themes/hipaper$ git pull FeaturesLogo: Image or TextYou can set a image as your logo instead of original text title. Like this: just enable avatar field in hipaper/_config.yml. 12345678# Put your avatar.jpg into `hexo-site/themes/hipaper/source/` directory.# url is target link (E.g. `url: https://hexo.io/logo.svg` or `url: css/images/mylogo.jpg`)avatar: enable: true width: 124 height: 124 bottom: 10 url: https://hexo.io/logo.svg Code HighlightHipaper use Tomorrow Theme for your code block. We have six options in total: default, normal, night, night blue, night bright, night eighties Above preview picture is default theme. the image below show other five Highlight themes. Modify highlight_theme in hipaper/_config.yml. 12345# Code Highlight theme# Available value:# default | normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: default SidebarYou can put your sidebar in left side, right side or bottom of your site by editing sidebar setting.Hipaper provides 7 built-in widgets: search social recent_posts category tag tagcloud archive All of them are enabled by default. You can edit them in widget setting. SearchHipaper use Insight Search to help you search anything inside your site without any third-party plugin. 12345# Searchsearch: insight: true # you need to install `hexo-generator-json-content` before using Insight Search swiftype: # enter swiftype install key here baidu: false # you need to disable other search engines to use Baidu search, options: true, false Attention: You need to install hexo-generator-json-content before using Insight Search. 1$ npm install -S hexo-generator-json-content FancyboxHipaper uses Fancybox to showcase your photos. You can use Markdown syntax or fancybox tag plugin to add your photos. 123![img caption](img url)&#123;% fancybox img_url [img_thumbnail] [img_caption] %&#125; Comment supportHipaper has native support for DuoShuo &amp; Disqus comment systems. Modify the following snippets to Hipaper hipaper/_config.yml: 123# comment ShortName, you can choose only ONE to display.duoshuo_shortname: iTimeTravelerdisqus_shortname: Browser support ContributingAll kinds of contributions (enhancements, new features, documentation &amp; code improvements, issues &amp; bugs reporting) are welcome. Looking forward to your pull request. Special thanks to ATHEMES, who designed the original theme FASHIONISTA for Wordpress. LicenseHipaper is under the MIT license. See the LICENSE file for details."},{"title":"Categories","date":"2016-08-16T07:00:44.000Z","updated":"2018-01-25T14:41:06.000Z","comments":false,"path":"categories/index.html","permalink":"http://sanwcoder.github.io/categories/index.html","excerpt":"","text":""},{"title":"Tags","date":"2016-08-11T04:12:45.000Z","updated":"2018-01-25T14:41:06.000Z","comments":true,"path":"tags/index.html","permalink":"http://sanwcoder.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"创建静态库","slug":"创建静态库","date":"2018-04-16T14:26:46.000Z","updated":"2018-04-16T15:44:11.000Z","comments":true,"path":"2018/04/16/创建静态库/","link":"","permalink":"http://sanwcoder.github.io/2018/04/16/创建静态库/","excerpt":"创建静态库的方式有两种，分别为.a跟.framework。","text":"创建静态库的方式有两种，分别为.a跟.framework。 创建.framework新建Xcode项目选择 Cocoa Touch Framework 新建一个测试类12345678910111213141516171819// Test.h@interface Test : NSObject/** 输出字符串 */+ (void)string;@end// Test.m#import \"Test.h\"@implementation Test/** 输出字符串 */+ (void)string&#123; NSLog(@\"framework test\");&#125;@end 配置headers-在Build Phases -&gt; Headers下将Project下的你要提供给外部调用的头文件拖到Public下 在target-&gt; build setting - &gt; link下 1、首先是Dead Code Stripping设置为NO，网上对此项的解释如下，大致意思是如果开启此项就会对代码中的”dead”、”unreachable”的代码过滤，不过这个开关是否关闭，似乎没有多大影响，不过为了完整还原framework中的代码，将此项关闭也未曾不可。2、然后将Link With Standard Libraries关闭，我想可能是为了避免重复链接3、最后将Mach-O Type设为Static Library，framework可以是动态库也可以是静态库，对于系统的framework是动态库，而用户制作的framework只能是静态库。 将静态库导入项目中确保已经导入 12345678910111213/// 导入头文件#import &lt;FrameworkTest/FrameworkTest.h&gt;@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [Test string];&#125; 创建.a-新建Xcode项目选择 Cocoa Touch Static Library 新建一个测试类12345678910111213141516171819// Test.h@interface Test : NSObject/** 输出字符串 */+ (void)string;@end// Test.m#import \"Test.h\"@implementation Test/** 输出字符串 */+ (void)string&#123; NSLog(@\"Cocoa Touch Static Library test\");&#125;@end 配置headers-在Build Phases -&gt; Copy Files下将你要提供给外部调用的头文件添加进来 在target-&gt; build setting - &gt; link下将Build Active Architecture Only设置为NO Build Active Architecture Only选项设置 Build Setting里面的Build Active Architecture Only设置为NO。Build Active Architecture Only设置为YES时，是为了debug的时候编译速度更快，此时它只编译当前的architecture版本。设置为NO时，会编译所有的版本。 切换scame在run 时为release，然后CMD+B编译项目 编译以后会在Xcode左侧Products文件夹下会生成.a文件，之后show in find，将.a文件佶include下的.h文件一起倒入项目 将静态库导入项目中确保已经导入 12345678910111213/// 导入头文件#import \"Test.h\"@interface ViewController ()@end@implementation ViewController- (void)viewDidLoad &#123; [super viewDidLoad]; // Do any additional setup after loading the view, typically from a nib. [Test string];&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/categories/iOS/"}],"tags":[{"name":".a","slug":"a","permalink":"http://sanwcoder.github.io/tags/a/"},{"name":".frmamework","slug":"frmamework","permalink":"http://sanwcoder.github.io/tags/frmamework/"}]},{"title":"音视频拼接","slug":"音视频拼接","date":"2018-04-16T09:10:50.000Z","updated":"2018-04-17T03:55:30.000Z","comments":true,"path":"2018/04/16/音视频拼接/","link":"","permalink":"http://sanwcoder.github.io/2018/04/16/音视频拼接/","excerpt":"在做音视频相关开发时会用到音视频拼接","text":"在做音视频相关开发时会用到音视频拼接 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 拼接音频 */- (void)formateAudioFile&#123; /// 1.创建资源 AVURLAsset *audioAsset1 = [AVURLAsset assetWithURL:[NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@\"MBA材料撰写一.m4a\" ofType:nil]]]; AVURLAsset *audioAsset2 = [AVURLAsset assetWithURL:[NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@\"MBA材料撰写二.m4a\" ofType:@\"\"]]]; /// 2.创建轨道 AVMutableComposition *composition = [AVMutableComposition composition]; /// 2.1 创建音频轨道 /// AVMediaTypeAudio : 音频 AVMediaTypeVideo ：视频 AVMutableCompositionTrack *audioTrack1 = [composition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:0]; /// AVMediaTypeAudio : 音频 AVMediaTypeVideo ：视频 AVMutableCompositionTrack *audioTrack2 = [composition addMutableTrackWithMediaType:AVMediaTypeAudio preferredTrackID:0]; /// 2.2 创建轨道素材 /// AVMediaTypeAudio : 音频 AVMediaTypeVideo ：视频 AVAssetTrack *assetTrack1 = [audioAsset1 tracksWithMediaType:AVMediaTypeAudio].firstObject; /// AVMediaTypeAudio : 音频 AVMediaTypeVideo ：视频 AVAssetTrack *assetTrack2 = [audioAsset2 tracksWithMediaType:AVMediaTypeAudio].firstObject; /// 2.3 将第一个轨道素材从零开始插入到轨道中 [audioTrack1 insertTimeRange:CMTimeRangeMake(kCMTimeZero, audioAsset1.duration) ofTrack:assetTrack1 atTime:kCMTimeZero error:nil]; /// 2.4 将第二个轨道素材从第一个轨道结束时间开始插入到轨道中 [audioTrack2 insertTimeRange:CMTimeRangeMake(kCMTimeZero, audioAsset2.duration) ofTrack:assetTrack2 atTime:audioAsset1.duration error:nil]; // 3.合并后的文件导出 - `presetName`要和之后的`session.outputFileType`相对应。 /// AVAssetExportPresetAppleM4A : 音频 AVAssetExportPresetLowQuality ：视频 AVAssetExportSession *session = [[AVAssetExportSession alloc] initWithAsset:composition presetName:AVAssetExportPresetAppleM4A]; // 3.1 合并后的文件地址。 NSString *outPutFilePath = [[NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject stringByDeletingLastPathComponent] stringByAppendingPathComponent:@\"MBA材料撰写.m4a\"]; if ([[NSFileManager defaultManager] fileExistsAtPath:outPutFilePath]) &#123; [[NSFileManager defaultManager] removeItemAtPath:outPutFilePath error:nil]; &#125; // 3.2 合并后的文件输入地址。 session.outputURL = [NSURL fileURLWithPath:outPutFilePath]; // AVFileTypeAppleM4A : 音频 AVFileTypeMPEG4 ：视频 session.outputFileType = AVFileTypeAppleM4A; //与上述的`present`相对应 session.shouldOptimizeForNetworkUse = YES; //优化网络 // 3.3 开始合并 [session exportAsynchronouslyWithCompletionHandler:^&#123; if (session.status == AVAssetExportSessionStatusCompleted) &#123; NSLog(@\"合并成功----%@\", outPutFilePath); &#125; else &#123; // 其他情况, 具体请看这里`AVAssetExportSessionStatus`. &#125; &#125;];&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/categories/iOS/"}],"tags":[{"name":"音视频","slug":"音视频","permalink":"http://sanwcoder.github.io/tags/音视频/"}]},{"title":"音视频录制及图片添加滤镜","slug":"音视频录制","date":"2018-04-10T07:01:29.000Z","updated":"2018-04-10T07:29:03.000Z","comments":true,"path":"2018/04/10/音视频录制/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/音视频录制/","excerpt":"使用原生API进行音视频录制的二种方式","text":"使用原生API进行音视频录制的二种方式 使用UIImagePickerController录制1234567891011121314151617181920212223242526272829303132333435363738394041424344- (void)imageControllerCapure&#123; // 1.判断摄像头可不可用 if (![UIImagePickerController isSourceTypeAvailable:UIImagePickerControllerSourceTypeCamera])&#123; [SWProgressHUB showWithInfoStatus:@\"没法找到摄像头\"]; return; &#125; // 2.判断支不支持录制视频 NSArray *availableMediaTypes = [UIImagePickerController availableMediaTypesForSourceType:UIImagePickerControllerSourceTypeCamera]; if (![availableMediaTypes containsObject:(NSString *)kUTTypeMovie])&#123; [SWProgressHUB showWithInfoStatus:@\"无法录制视频\"]; return; &#125; // 3.创建PickerView UIImagePickerController *videoImage = [[UIImagePickerController alloc]init]; // 4.设置可用类型 摄像头还是图库 videoImage.sourceType = UIImagePickerControllerSourceTypeCamera; // 5.设置媒体类型 图片还是视频 videoImage.mediaTypes = @[(NSString *)kUTTypeMovie]; // 6.设置媒体质量 高，中，低.... videoImage.videoQuality = UIImagePickerControllerQualityTypeHigh; // 7.设置代理 videoImage.delegate = self; // 8.设置摄像头模式 前置还是后置 videoImage.cameraDevice = UIImagePickerControllerCameraDeviceRear; [self presentViewController:videoImage animated:YES completion:nil];&#125;#pragma mark - 代理- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary&lt;NSString *,id&gt; *)info&#123; WELog(@\"infoData = %@\",info);// infoData = &#123;// UIImagePickerControllerMediaType = \"public.movie\";// UIImagePickerControllerMediaURL = \"file:///private/var/mobile/Containers/Data/Application/676A90DD-7CC8-4BCE-B0AF-052ED0686CA9/tmp/52160991560__4E8816F7-B81D-49F8-ABAC-F58019E2C0E6.MOV\";// &#125; // 录制成功取出数据及地址 NSData *data = [NSData dataWithContentsOfURL:info[UIImagePickerControllerMediaURL]]; WELog(@\"videoData = %@\",data); // 将资源保存在图库中 ALAssetsLibrary *al = [[ALAssetsLibrary alloc]init]; [al writeVideoAtPathToSavedPhotosAlbum:info[UIImagePickerControllerMediaURL] completionBlock:^(NSURL *assetURL, NSError *error) &#123; WELog(@\"assetURL = %@\",assetURL); [self dismissViewControllerAnimated:YES completion:nil]; &#125;];&#125; 使用AVCaptureSession录制12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485@implementation VideoCaptureController&#123; AVCaptureSession *_sesstion;&#125;- (void)reportWithFoundtion&#123; // 1.添加视频调度sesstion 管理输入输出设备 _sesstion = [[AVCaptureSession alloc]init]; // 1.1 设置分辨率 if ([_sesstion canSetSessionPreset:AVCaptureSessionPreset1280x720]) &#123; _sesstion.sessionPreset=AVCaptureSessionPreset1280x720; &#125; // 2.添加输入设备 AVCaptureDevice *videoDevice = [self getCameraDeviceWithPosition:AVCaptureDevicePositionBack]; AVCaptureDevice *audioDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeAudio]; // 3.添加输入流 AVCaptureDeviceInput *videoInput = [[AVCaptureDeviceInput alloc]initWithDevice:videoDevice error:nil]; AVCaptureDeviceInput *audioInput = [[AVCaptureDeviceInput alloc]initWithDevice:audioDevice error:nil]; // 4.添加输入流到sesstion if ([_sesstion canAddInput:videoInput]) &#123; [_sesstion addInput:videoInput]; &#125; if ([_sesstion canAddInput:audioInput]) &#123; [_sesstion addInput:audioInput]; &#125; // 5.添加输出 AVCaptureMovieFileOutput *outPut = [[AVCaptureMovieFileOutput alloc]init]; AVCaptureConnection *captureConnection = [outPut connectionWithMediaType:AVMediaTypeVideo]; if ([captureConnection isVideoStabilizationSupported]) &#123; captureConnection.preferredVideoStabilizationMode =AVCaptureVideoStabilizationModeAuto; &#125; if ([_sesstion canAddOutput:outPut]) &#123; [_sesstion addOutput:outPut]; &#125;// [outPut startRecordingToOutputFileURL:[NSURL fileURLWithPath:[NSString stringWithFormat:@\"%@.mp4\",PTCacheDir]] recordingDelegate:self]; // 创建视频预览层，用于实时展示摄像头状态 AVCaptureVideoPreviewLayer *captureVideoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc]initWithSession:_sesstion]; CALayer *layer = self.view.layer; layer.masksToBounds = YES; captureVideoPreviewLayer.frame = layer.bounds; // 填充模式 captureVideoPreviewLayer.videoGravity=AVLayerVideoGravityResizeAspectFill; // 将视频预览层添加到界面中 [layer addSublayer:captureVideoPreviewLayer]; [_sesstion startRunning]; UIButton *save = [UIButton buttonWithType:UIButtonTypeCustom]; [save setTitle:@\"保存\" forState:UIControlStateNormal]; save.frame = CGRectMake(100, 100, 100, 100); save.backgroundColor = kMainColor; [save addTarget:self action:@selector(stop:) forControlEvents:UIControlEventTouchUpInside]; [self.view addSubview:save];&#125;- (AVCaptureDevice *)getCameraDeviceWithPosition:(AVCaptureDevicePosition )position&#123; NSArray *cameras= [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; for (AVCaptureDevice *camera in cameras) &#123; if ([camera position] == position) &#123; return camera; &#125; &#125; return nil;&#125;- (void)captureOutput:(AVCaptureFileOutput *)captureOutput didStartRecordingToOutputFileAtURL:(NSURL *)fileURL fromConnections:(NSArray *)connections&#123; WELog(@\"开始录制\");&#125;- (void)captureOutput:(AVCaptureFileOutput *)captureOutput didResumeRecordingToOutputFileAtURL:(NSURL *)fileURL fromConnections:(NSArray *)connections&#123; WELog(@\"重新录制\");&#125;- (void)captureOutput:(AVCaptureFileOutput *)captureOutput didFinishRecordingToOutputFileAtURL:(NSURL *)outputFileURL fromConnections:(NSArray *)connections error:(NSError *)error&#123; WELog(@\"结束录制\");&#125;- (void)stop:(UIButton *)sender&#123; sender.selected = !sender.selected; if (sender.selected) &#123; [_sesstion stopRunning]; &#125; else&#123; [_sesstion startRunning]; &#125;&#125;@end 图片添加简单滤镜12345678910111213141516- (UIImage *)filterImage:(UIImage *)image&#123; CIImage *imag = [CIImage imageWithCGImage:image.CGImage]; NSLog(@\"%@\",[CIFilter filterNamesInCategory:kCICategoryDistortionEffect]); // 创建修改颜色的滤镜对象 CIFilter *fifle = [CIFilter filterWithName:@\"CIColorMonochrome\"]; // 创建滤镜对象-将图片加入滤镜 [fifle setValue:imag forKey:kCIInputImageKey]; // 设置颜色 [fifle setValue:[CIColor colorWithRed:1.000 green:0.759 blue:0.592 alpha:1] forKey:kCIInputColorKey]; // 创建上下文对象（图板） CIContext *context = [CIContext contextWithOptions:nil]; // 生成新图片 CGImageRef imageRef = [context createCGImage:fifle.outputImage fromRect:fifle.outputImage.extent]; image = [UIImage imageWithCGImage:imageRef]; return image;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/categories/iOS/"}],"tags":[{"name":"音视频","slug":"音视频","permalink":"http://sanwcoder.github.io/tags/音视频/"},{"name":"图片滤镜","slug":"图片滤镜","permalink":"http://sanwcoder.github.io/tags/图片滤镜/"}]},{"title":"Swift-perfect开发抓取程序","slug":"Swift-perfect开发抓取程序","date":"2018-04-10T06:36:06.000Z","updated":"2018-04-10T06:43:42.000Z","comments":true,"path":"2018/04/10/Swift-perfect开发抓取程序/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/Swift-perfect开发抓取程序/","excerpt":"Swift-perfect开发抓取程序","text":"Swift-perfect开发抓取程序 创建基本程序创建文件夹并进入12~ mkdir Literary_Crawler~ cd Literary_Crawler 创建Package.swift这个文件是SPM（Swift软件包管理器）编译项目时必须要用到的文件1234567891011121314// 创建Package.swift ~ vim Package.swiftimport PackageDescriptionlet package = Package( name: \"LiteraryCrawler\", // 项目名称，使用swift package generate-xcodeproj时生成的项目名 targets: [], // 依赖包，使用swift build 时会自动下载包含的所有包 dependencies: [ .Package(url: \"https://github.com/PerfectlySoft/Perfect-HTTPServer.git\", majorVersion: 2), .Package(url:\"https://github.com/PerfectlySoft/Perfect-MySQL.git\", majorVersion: 2), .Package(url: \"https://github.com/PerfectlySoft/Perfect-CURL.git\", majorVersion: 2) ]) 创建Sources文件夹保存源程序及其main.swift123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475~ mkdir Sources~ cd Sources~ vim main.swiftmain.swiftimport PerfectLibimport PerfectHTTPimport PerfectHTTPServerimport PerfectCURLimport MySQLlet testHost = \"127.0.0.1\"let testUser = \"root\"let testPassword = \"123456\"let testDB = \"LiteraryDB\"func fetchData(response:HTTPResponse) &#123; let mysql = MySQL() // 创建一个MySQL连接实例 let connected = mysql.connect(host: testHost, user: testUser, password: testPassword) guard connected else &#123; // 验证一下连接是否成功 print(mysql.errorMessage()) return &#125; defer &#123; mysql.close() //这个延后操作能够保证在程序结束时无论什么结果都会自动关闭数据库连接 &#125; // 选择具体的数据Schema guard mysql.selectDatabase(named: testDB) else &#123; Log.info(message: \"数据库选择失败。错误代码：\\(mysql.errorCode()) 错误解释：\\(mysql.errorMessage())\") return &#125; // 运行查询（比如返回在options数据表中的所有数据行） let querySuccess = mysql.query(statement: \"SELECT * FROM tb_user\") // 确保查询完成 guard querySuccess else &#123; return &#125; // 在当前会话过程中保存查询结果 let results = mysql.storeResults()! //因为上一步已经验证查询是成功的，因此这里我们认为结果记录集可以强制转换为期望的数据结果。当然您如果需要也可以用if-let来调整这一段代码。 results.forEachRow &#123; row in Log.info(message: \"\\(row)\") &#125; Log.info(message: \"连接成功\") response.appendBody(string: \"mysql连接成功\") response.completed()&#125;/// 1.创建Serverlet server = HTTPServer()/// 2.创建路由表var routes = Routes()/// 3.添加路由到路由表routes.add(method: .get, uri: \"/login\") &#123; (request, response) in &#125;/// 4.将路由表添加到Serverserver.addRoutes(routes)/// 1.1 监听8181端口server.serverPort = 8181func request() &#123; let url = CURL.init(url: \"http://www.jianshu.com/p/457922e0676c\") let (_, _, bytes) = url.performFully() guard let html = String.init(bytes: bytes, encoding: .utf8) else &#123; return &#125; print(html)&#125;/// 5.启动Serverdo &#123; try server.start() request()&#125; catch PerfectError.networkError(let err, let msg) &#123; print(\"网络出现错误：\\(err) \\(msg)\")&#125; 生成xcodeproj 123\"__TFE10FoundationSSCuRxs8SequenceWx8Iterator7Element_zVs5UInt8rfT5bytesx8encodingVES_SS8Encoding_GSqSS_\", referenced from: \"__TFVE10FoundationSS8Encodingau4utf8S0_\", referenced from:","categories":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://sanwcoder.github.io/tags/Swift/"},{"name":"perfect","slug":"perfect","permalink":"http://sanwcoder.github.io/tags/perfect/"},{"name":"抓取","slug":"抓取","permalink":"http://sanwcoder.github.io/tags/抓取/"}]},{"title":"cocospod相关操作","slug":"CocosPod相关操作","date":"2018-04-10T06:26:59.000Z","updated":"2018-04-10T06:33:33.000Z","comments":true,"path":"2018/04/10/CocosPod相关操作/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/CocosPod相关操作/","excerpt":"在项目中使用cocospod管理第三方库的一些基本操作","text":"在项目中使用cocospod管理第三方库的一些基本操作 cocospod 基本操作 创建podfile文件 pod init 安装第三方库 12345678910// 在podfile中添加第三方库如# Uncomment this line to define a global platform for your projectplatform :ios, '9.0'use_frameworks!target 'LiteraryHeaven' dopod 'SVProgressHUD' pod 'Heimdall', '~&gt; 1.0.0'# pod 'ReactiveCocoa','~&gt; 4.0.0'end 安装 1pod install cocospod 更新 1&gt; 先切换gem源 12345678910gem sources --remove https://rubygems.org/`gem source -a https://gems.ruby-china.org // 查看是否切换成功gem source -l打印出*** CURRENT SOURCES *** https://gems.ruby-china.org就说明切换成功 2&gt;升级 sudo gem install -n /usr/local/bin cocoapods --pre 3&gt; 查看版本 pod --version 4&gt; 设置cocospod仓库 12pod repo update// pod setup","categories":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/categories/iOS/"}],"tags":[{"name":"cocospod","slug":"cocospod","permalink":"http://sanwcoder.github.io/tags/cocospod/"}]},{"title":"Swift-perfect服务端开发","slug":"Swift-perfect服务端开发","date":"2018-04-10T06:13:58.000Z","updated":"2018-04-10T06:23:31.000Z","comments":true,"path":"2018/04/10/Swift-perfect服务端开发/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/Swift-perfect服务端开发/","excerpt":"Swift-perfect服务端开发","text":"Swift-perfect服务端开发 准备阶段（SPM）依存关系12345678910111213141516~ swfit --version // swift版本必须在3.0以上才能编译``` #### 克隆基础模板 ```objcgit clone https://github.com/PerfectlySoft/PerfectTemplate.git``` 所有的SPM项目至少要包括一个 Sources 目录和一个 Package.swift 文件 #### 编译 ```objcswift build // 编译.build/debug/PerfectTemplate // 运行swift build -c release // 编译一个用于发行的版本运行后可发行版本的可执行程序被放在了.build/release/目录下swift build --clean // 清理所有编译临时文件并产生一个干净的版本 swift build --clean=dist // .build目录和Packages目录都会被删除。并且能够重新下载所有依存关系以获得最新版本对项目的支持。 生成xcode项目1swift package generate-xcodeproj 下载mysql依赖包在Package.swift 中添加MYSQL并重新编译12.Package(url:\"https://github.com/PerfectlySoft/Perfect-MySQL.git\",majorVersion : 2)swift build // 重新编译 安装Homebrew1. perfect推荐使用Homebrew安装mysql如果按照homeBrow安装完则不用配置任何东西就可以运行12345678// 安装Homebrew，Homebrew安装在/user/local目录下，同时它会创建/user/local/Cellar目录用于存放通过Homebrew安装的程序，运行brew -v查看安装版本// 1. `/usr/bin/ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"`// 2.安装完成顺势更新 brew update // 3.安装完成以后检查文件运行是否正常。注意警告，如果之前手动安装过node最好先删除node文件 local/lib , local/include brew doctor 2. Homebrew常用命令12345678910111213brew search * --搜索程序，例：brew search pythonbrew install * --安装程序，例：brew install pythonbrew uninstall * --卸载程序，例：brew uninstall pythonbrew list --列举通过Homebrew安装的程序brew update --更新Homebrewbrew upgrade [*] --更新某个具体程序，或者更新所有程序brew cleanup [*] --删除某个具体程序，或者删除所有老版程序brew outdated --查看哪些程序需要更新brew home * --用浏览器打开brew info * --显示软件内容信息brew deps * --显示包依赖brew server * --启动web服务器，可以通过浏览器访问http://localhost:4567/ 来同网页来管理包brew -h --查看帮助 3. 删除Homebrew12345cd `brew –prefix`rm -rf Cellarbrew prunerm -rf Library .git .gitignore bin/brew README.md share/man/man1/brewrm -rf ~/Library/Caches/Homebrew 4. 使用Homebrew安装mysql123456789101112// 1.安装mysqlbrew install mysql// 2.开启MySQL服务mysql.server start // brew services start mysql// 重新启动mysql服务mysql.server restart// 停止mysql服务mysql.server stop // brew services stop mysql// 3.初始化MySQL配置向导mysql_secure_installation// 4.连接mysqlmysql -u root -p MySQL配置1. 初始化MySQL配置向导mysql_secure_installation1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 启动mysql➜ local mysql.server start Starting MySQL. SUCCESS! // 运行配置➜ local mysql_secure_installationSecuring the MySQL server deployment.// validate_password为密码安全验证，如果不需要或者安全级别低 在/usr/local/etc/my.cnf文件中增加validate-password=OFF validate_password_policy=LOWConnecting to MySQL using a blank password.The 'validate_password' plugin is installed on the server.The subsequent steps will run with the existing configurationof the plugin.Please set the password for root here.New password: Re-enter new password: Estimated strength of the password: 0 Do you wish to continue with the password provided?(Press y|Y for Yes, any other key for No) : yBy default, a MySQL installation has an anonymous user,allowing anyone to log into MySQL without having to havea user account created for them. This is intended only fortesting, and to make the installation go a bit smoother.You should remove them before moving into a productionenvironment.// 删除默认无密码用户Remove anonymous users? (Press y|Y for Yes, any other key for No) : ySuccess.Normally, root should only be allowed to connect from'localhost'. This ensures that someone cannot guess atthe root password from the network.// 禁止远程root登录Disallow root login remotely? (Press y|Y for Yes, any other key for No) : ySuccess.By default, MySQL comes with a database named 'test' thatanyone can access. This is also intended only for testing,and should be removed before moving into a productionenvironment.// 删除默认自带的test数据库Remove test database and access to it? (Press y|Y for Yes, any other key for No) : y - Dropping test database...Success. - Removing privileges on test database...Success.Reloading the privilege tables will ensure that all changesmade so far will take effect immediately.Reload privilege tables now? (Press y|Y for Yes, any other key for No) : ySuccess.All done! 2. mysql测试123456789CREATE DATABASE `unitedtrade` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci;// 创建用户CREATE USER 'trade'@'%' IDENTIFIED BY 'trade';// 设置用户：GRANT USAGE ON * . * TO 'trade'@'%' IDENTIFIED BY 'trade' WITH MAX_QUERIES_PER_HOUR 0 MAX_CONNECTIONS_PER_HOUR 0 MAX_UPDATES_PER_HOUR 0 MAX_USER_CONNECTIONS 0 ;// 用户赋权：GRANT ALL PRIVILEGES ON `unitedtrade` . * TO 'trade'@'%' WITH GRANT OPTION ;// 刷新权限：flush privileges; 3. MySQL其他操作123456// 终端退出mysql编辑\\q// 关闭mysql:mysql stop// 安全模式启动MySQLmysqld_safe --skip-grant-tables 4. perfect连接mysql配置123// 将mysqlclient.pc文件设置为可读写后删除-fno-omit-frame-pointer内容。// 文件路径: /usr/local/lib/pkgconfig/mysqlclient.pc/ 5. 彻底移除mysql1234567891011121314// 通过HomeBrew安装从头开始brew remove mysql brew cleanup launchctl unload -w ~/Library/LaunchAgents/com.mysql.mysqld.plist // 设置了开机自动开启rm ~/Library/LaunchAgents/com.mysql.mysqld.plist // 设置了开机自动开启// 通过下载包直接安装下面开始sudo rm /usr/local(/var)/mysqlsudo rm -rf /usr/local(/var)/mysql*sudo rm -rf /Library/StartupItems/MySQLCOM // 设置了启动项sudo rm -rf /Library/PreferencePanes/My* // 设置了启动项(编辑 /etc/hostconfig) sudo vi /etc/hostconfig (删除行 MYSQLCOM=-YES)sudo rm -rf /Library/Receipts/mysql*sudo rm -rf /Library/Receipts/MySQL*sudo rm -rf /var/db/receipts/com.mysql.* 使用自己手动安装完成后需要在finder中找到相应的mysql文件 遇到error :Header ‘/usr/local/include/mysql/mysql.h’时找到mysql文件并替换/usr/local/mysql-5.7.15-osx10.11-x86_64/include/mysql.h 遇到找不到lmysqlclient文件时，在Target中找到MySQL，找到Library Search Paths中加上/usr/local/mysql-5.7.15-osx10.11-x86_64l/lib","categories":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://sanwcoder.github.io/tags/Swift/"},{"name":"perfect","slug":"perfect","permalink":"http://sanwcoder.github.io/tags/perfect/"},{"name":"mysql","slug":"mysql","permalink":"http://sanwcoder.github.io/tags/mysql/"},{"name":"homebrow","slug":"homebrow","permalink":"http://sanwcoder.github.io/tags/homebrow/"}]},{"title":"Swift和OC混编","slug":"Swift和OC混编","date":"2018-04-10T06:05:43.000Z","updated":"2018-04-10T06:13:26.000Z","comments":true,"path":"2018/04/10/Swift和OC混编/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/Swift和OC混编/","excerpt":"在OC项目中添加Swift文件进行混编","text":"在OC项目中添加Swift文件进行混编 新建类language选择swift 继续下一步会有如下提示，点击创建，意思是在oc项目中使用Swift语言需要创建桥接文件默认桥接文件名// 项目名-Bridging-Header.h此文件中存放要在swift文件中用到的OC文件的头文件即Swift调用OC 手动更改默认的桥接文件 Swift调用OC跟OC调用Swift Swift调用OC OC调用Swift OC调用Swift和Swift调用OC相似，Swift调用OC是通过桥接文件中定义的头文件将相应的OC类转化为Swift类使用，而OC调用Swift需要引入系统自动生成的项目名-Swift.h文件 // #import “项目名-Swift.h”,会默认将Swift类转化为OC类供OC调用，此文件在项目中是看不见的，但导入以后会看到相应的内容。注:OC 能调用的Swift类，必须继承自NSObject或NSObject的派生类才能使用 项目名-Swift.h文件内容 我们也可以更改项目名称，导入#import “修改后的名-Swift.h”","categories":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/categories/iOS/"}],"tags":[{"name":"Swift","slug":"Swift","permalink":"http://sanwcoder.github.io/tags/Swift/"},{"name":"Object-C","slug":"Object-C","permalink":"http://sanwcoder.github.io/tags/Object-C/"}]},{"title":"应用内切换系统语言","slug":"应用内切换系统语言","date":"2018-04-10T05:57:09.000Z","updated":"2018-04-10T06:25:07.000Z","comments":true,"path":"2018/04/10/应用内切换系统语言/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/应用内切换系统语言/","excerpt":"应用内切换系统语言","text":"应用内切换系统语言 创建工具类123456789101112131415161718192021222324252627282930313233343536373839404142434445// LocalizableTool.h+(NSBundle *)bundle;//获取当前资源文件+(void)initUserLanguage;//初始化语言文件+(NSString *)userLanguage;//获取应用当前语言+(void)setUserlanguage:(NSString *)language;//设置当前语言// LocalizableTool.m+ ( NSBundle * )bundle&#123; return bundle;&#125;+(void)initUserLanguage&#123; NSUserDefaults *userDef = [NSUserDefaults standardUserDefaults]; NSString *string = [userDef valueForKey:kCommonLang]; if(string.length == 0)&#123; NSString *current = [WEFileUtils getLangugeAndCountryID][0]; current = [WEFileUtils returnLocalStr:current]; string = current; [userDef setValue:current forKey:kCommonLang]; [userDef synchronize];//持久化，不加的话不会保存 &#125; string = [INBaseMethod returnLocalStr:string]; // 获取文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:[NSString stringWithFormat:@\"%@.lproj\",string] ofType:nil]; bundle = [NSBundle bundleWithPath:path];//生成bundle&#125;+(NSString *)userLanguage&#123; NSUserDefaults *userDef = [NSUserDefaults standardUserDefaults]; NSString *language = [userDef valueForKey:kCommonLang]; return language;&#125;+(void)setUserlanguage:(NSString *)language&#123; // 1.第一步改变bundle的值 NSString *path = [[NSBundle mainBundle] pathForResource:[NSString stringWithFormat:@\"%@.lproj\",language] ofType:nil]; bundle = [NSBundle bundleWithPath:path];&#125; 使用12345// 在AppDelegate里进行初始化 [LocalizableTool initUserLanguage];// 定义一个宏用来从哪个文件中读数据// key 代表你要在某个文件中需要读取的key值，table为国际化文件名#define kLocalizedString(key,comment) [[INLocalizableTool bundle] localizedStringForKey:(key) value:@\"\" tab","categories":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/tags/iOS/"},{"name":"国家化","slug":"国家化","permalink":"http://sanwcoder.github.io/tags/国家化/"}]},{"title":"如何在AppStore下载国外软件(多图慎点）","slug":"如何在AppStore下载国外软件","date":"2018-04-10T05:47:21.000Z","updated":"2018-04-10T05:55:13.000Z","comments":true,"path":"2018/04/10/如何在AppStore下载国外软件/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/如何在AppStore下载国外软件/","excerpt":"由于苹果的AppStore和Apple ID是分国家区域的，所以一般手机中的AppStore都是根据你所在国家而提供相应的软件，Apple ID也是根据你注册时所选销售区域来确定你可以下载那个国家或者区域的软件，同时要求你的AppStore和Apple ID的国家和区域必须相同才能下载相应的软件，所以本篇文章将从头介绍如何注册国外账号以及切换AppStore。","text":"由于苹果的AppStore和Apple ID是分国家区域的，所以一般手机中的AppStore都是根据你所在国家而提供相应的软件，Apple ID也是根据你注册时所选销售区域来确定你可以下载那个国家或者区域的软件，同时要求你的AppStore和Apple ID的国家和区域必须相同才能下载相应的软件，所以本篇文章将从头介绍如何注册国外账号以及切换AppStore。 注册国外Apple ID（以下方法均以注册法国账号为例，其他国家步骤大体相同） 使用PC点击进入：官网链接 将此界面往下拉到底部，找到中国国旗地方，点击切换国家 点击你所需要注册账号的国家以后返回到所选国家的创建界面，此时语言也跟着改变（法语），点击注册新账号，调到注册页 调到注册页开始注册注:除了注册邮箱，密码，注册区域以外其他的可以任意填写 填写完成后点击下一步，将会收到苹果的一份验证邮件，将收到的验证码输入到这儿完成验证。 点击右下角按钮，完成注册。之后推出。使用手机进行下一步设置。 完成第二步以后使用手机进行设置 打开手机设置—–&gt;iTunes Store 与AppStore 点击Apple ID登陆，如果已经登陆，注销使用新注册的账号登陆 登陆成功以后会提示尚未在iTunes Store使用需要检查，点击进行检查 点击检查以后会进入填写一些销售区域信息，选择和注册账号一样的国家 点击下一步 这一步要选择跳过填写银行卡信息，选择最后一项不使用银行卡 点击上步提交以后基本的设置就算完成了 点击上一步以后会调到此页面，选择第一项切换AppStore,如果此时出现白屏则表示切换没有成功，解决方法是连续点击右下角的更新按钮直到闪屏。 切换成功","categories":[],"tags":[]},{"title":"UUID解决方案","slug":"UUID解决方案","date":"2018-04-10T05:31:47.000Z","updated":"2018-04-10T05:38:05.000Z","comments":true,"path":"2018/04/10/UUID解决方案/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/UUID解决方案/","excerpt":"在项目中用到了UUID，需要在用户第一次安装以后再次安装时UUID不会再变化，作为一个唯一的标识，就这个问题找了一些资料，记录下来以便下次使用。","text":"在项目中用到了UUID，需要在用户第一次安装以后再次安装时UUID不会再变化，作为一个唯一的标识，就这个问题找了一些资料，记录下来以便下次使用。 具体解决方案参考来源 http://www.tuicool.com/articles/Ir63UbI UUID解决方案主要采用了keychain存储的解决方案，我们知道如果使用NSUserDefaults来存储的话当卸载以后数据也将会一并删除，目前最好的解决方案就是使用keychain存储。 创建keychain 创建完以后会自动生成一个entitlements文件 主要代码，自定义一个存储类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546 #import \"INKeyChainStore.h\" @implementation INKeyChainStore+ (NSMutableDictionary *)getKeychainQuery:(NSString *)service &#123; return [NSMutableDictionary dictionaryWithObjectsAndKeys: (id)kSecClassGenericPassword,(id)kSecClass, service, (id)kSecAttrService, service, (id)kSecAttrAccount, (id)kSecAttrAccessibleAfterFirstUnlock,(id)kSecAttrAccessible, nil];&#125;// 将值保存在keychain中+ (void)save:(NSString *)service data:(id)data &#123; NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; SecItemDelete((CFDictionaryRef)keychainQuery); [keychainQuery setObject:[NSKeyedArchiver archivedDataWithRootObject:data] forKey:(id)kSecValueData]; SecItemAdd((CFDictionaryRef)keychainQuery, NULL);&#125;// 获取存进入的值+ (id)load:(NSString *)service &#123; id ret = nil; NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; [keychainQuery setObject:(id)kCFBooleanTrue forKey:(id)kSecReturnData]; [keychainQuery setObject:(id)kSecMatchLimitOne forKey:(id)kSecMatchLimit]; CFDataRef keyData = NULL; if (SecItemCopyMatching((CFDictionaryRef)keychainQuery, (CFTypeRef *)&amp;keyData) == noErr) &#123; @try &#123; ret = [NSKeyedUnarchiver unarchiveObjectWithData:(__bridge NSData *)keyData]; &#125; @catch (NSException *e) &#123; &#125; @finally &#123; &#125; &#125; if (keyData) CFRelease(keyData); return ret;&#125;// 删除值+ (void)deleteKeyData:(NSString *)service &#123; NSMutableDictionary *keychainQuery = [self getKeychainQuery:service]; SecItemDelete((CFDictionaryRef)keychainQuery);&#125;@end 自定义一个类来获取UUID 1234567891011121314151617// 获取设备UUID+ (NSString *)getUUID&#123; NSString * strUUID = (NSString *)[INKeyChainStore load:@\"uuid.yaowen\"]; //首次执行该方法时，uuid为空 if ([strUUID isEqualToString:@\"\"] || !strUUID) &#123; // 生成一个uuid的方法 CFUUIDRef uuidRef = CFUUIDCreate(kCFAllocatorDefault); strUUID = (NSString *)CFBridgingRelease(CFUUIDCreateString (kCFAllocatorDefault,uuidRef)); strUUID = [strUUID stringByReplacingOccurrencesOfString:@\"-\" withString:@\"\"]; // 将该uuid保存到keychain [INKeyChainStore save:@\"uuid.yaowen\" data:strUUID]; &#125; return strUUID;&#125;","categories":[],"tags":[]},{"title":"收到推送时程序内的处理方案","slug":"收到推送时程序内的处理方案","date":"2018-04-10T04:27:17.000Z","updated":"2018-04-10T04:37:37.000Z","comments":true,"path":"2018/04/10/收到推送时程序内的处理方案/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/收到推送时程序内的处理方案/","excerpt":"在应用中经常会添加推送，在我们的项目中也用到了推送，推送添加的是友盟的第三方推送方案，接入友盟的SDK只要按照步骤，接进来也十分简单，完全可以收到推送数据，但问题是在收到推送数据时如何去处理收到的信息以及如何跳转相应的界面？这是我这篇文章主要介绍的。","text":"在应用中经常会添加推送，在我们的项目中也用到了推送，推送添加的是友盟的第三方推送方案，接入友盟的SDK只要按照步骤，接进来也十分简单，完全可以收到推送数据，但问题是在收到推送数据时如何去处理收到的信息以及如何跳转相应的界面？这是我这篇文章主要介绍的。 解决思路iOS提供收到推送时的处理方法，但是收到推送应该从几个方面来考虑这才是关键的点，对于一个刚接触的人来说也是不知所措，之后再网上查找零零碎碎的找到了一些突破点，才完成了对于收到推送的处理方式，主要从以下两个方面来考虑。 当程序没有死掉即在在前台或者后台时 1234567/** * 收到推送时会在AppDelegate的didReceiveRemoteNotification中响应事件 */- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo&#123; // 这里做收到推送时的处理userInfo为收到的数据&#125; 程序在运行在前台即处于UIApplicationStateActive状态 在UIApplicationStateActive时只需要定义一个alertView来处理，在代理方法里跳转相应的详情，当然这个跳转必须要有navigationController来跳转并且navigationController要作为一个属性。 1234567891011121314151617181920212223242526272829303132- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo&#123; // 保存推送数据 self.userInfos = userInfo; // 定制自定义的弹框 if([UIApplication sharedApplication].applicationState == UIApplicationStateActive) &#123; UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@\"有新的要闻推荐哦~\" message:userInfo[@\"aps\"][@\"alert\"] delegate:self cancelButtonTitle:@\"取消\" otherButtonTitles:@\"立即前往\", nil]; [alertView show]; &#125;&#125;// iOS 10 会走新 API, iOS 10 以前会走到老 API#if __IPHONE_OS_VERSION_MAX_ALLOWED &gt;= __IPHONE_10_0// App 用户点击通知的回调// 无论本地推送还是远程推送都会走这个回调- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler &#123; WELog(@\"[XGDemo] click notification\"); [XGPush handleReceiveNotification:response.notification.request.content.userInfo successCallback:^&#123; WELog(@\"[XGDemo] Handle receive success\"); &#125; errorCallback:^&#123; WELog(@\"[XGDemo] Handle receive error\"); &#125;]; // 处理推送 [self receivePushInfo:response.notification.request.content.userInfo]; completionHandler();&#125; // App 在前台弹通知需要调用这个接口 (void)userNotificationCenter:(UNUserNotificationCenter )center willPresentNotification:(UNNotification )notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler { WELog(@”[XGDemo] click notification”); [XGPush handleReceiveNotification:notification.request.content.userInfo successCallback:^{ WELog(@&quot;[XGDemo] Handle receive success&quot;); } errorCallback:^{ WELog(@&quot;[XGDemo] Handle receive error&quot;); }]; // 处理推送 [self receivePushInfo:notification.request.content.userInfo]; completionHandler(UNNotificationPresentationOptionBadge | UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert);} alerView的代理方法里执行跳转详情 // pragma mark -跳转到推送详情页 (void)notificationDetailVc { INHelpProtrolViewController *help = [[INHelpProtrolViewController alloc]init]; help.urlString = self.userInfos[@”src_link”]; [self.mainNavigationController pushViewController:help animated:YES];} 程序在运行在后台但没死掉即处于UIApplicationStateInactive状态时 当你点击通知栏上的通知时程序程序会触发didReceiveRemoteNotification方法 12345678910- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo&#123; if ([UIApplication sharedApplication].applicationState == UIApplicationStateInactive)&#123; // 跳转详情页面 INHelpProtrolViewController *help = [[INHelpProtrolViewController alloc]init]; help.urlString = self.userInfos[@\"src_link\"]; [self.mainNavigationController pushViewController:help animated:YES]; &#125;&#125; 当程序完全死掉时 12345678910111213141516// 程序启动时- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions &#123;/// 上面创建window，navgationController等操作，创建完成后判断是否是由推送打开之后跳转#pragma mark -判断是否由推送打开 // 判断是否是通过推送打开app NSDictionary *userInfos = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey]; if (userInfos) &#123; // 保存数据 self.userInfos = userInfos; // 跳转详情 INHelpProtrolViewController *help = [[INHelpProtrolViewController alloc]init]; help.urlString = self.userInfos[@\"src_link\"]; [self.mainNavigationController pushViewController:help animated:YES]; &#125; return YES;&#125;","categories":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/tags/iOS/"},{"name":"推送","slug":"推送","permalink":"http://sanwcoder.github.io/tags/推送/"}]},{"title":"iOS推送","slug":"iOS推送","date":"2018-04-10T04:15:57.000Z","updated":"2018-04-10T04:26:06.000Z","comments":true,"path":"2018/04/10/iOS推送/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/iOS推送/","excerpt":"我们的产品是一款新闻类的APP要求按照用户行为推送相应的新闻数据，所以要用到推送，在程序启动的时候会请求用户是否打开推送，如果打开则能收到推送的新闻内容，相应的功能按钮也将打开，如果没有打开用户可以在更多设置里去手动打开，在我们的程序中并没有通过打开和关闭按钮去打开推送，而是让用户跳到系统的设置页面去自己选择是否打开。","text":"我们的产品是一款新闻类的APP要求按照用户行为推送相应的新闻数据，所以要用到推送，在程序启动的时候会请求用户是否打开推送，如果打开则能收到推送的新闻内容，相应的功能按钮也将打开，如果没有打开用户可以在更多设置里去手动打开，在我们的程序中并没有通过打开和关闭按钮去打开推送，而是让用户跳到系统的设置页面去自己选择是否打开。 推送流程 设置开关状态值 12// 设置开关状态self.switchView.on = [[NSUserDefaults standardUserDefaults] boolForKey:@\"push\"]; 判断是否打开推送 12345678910111213141516171819/*** 判断是否打开推送*/+ (BOOL)isAllowedNotification &#123; // iOS8 check if user allow notification if ([[[UIDevice currentDevice] systemVersion] floatValue] &gt;= 8.0) &#123; // system is iOS8 UIUserNotificationSettings *setting = [[UIApplication sharedApplication] currentUserNotificationSettings]; if (UIUserNotificationTypeNone != setting.types) &#123; return YES; &#125; &#125; else &#123; //iOS7 UIRemoteNotificationType type = [[UIApplication sharedApplication] enabledRemoteNotificationTypes]; if(UIRemoteNotificationTypeNone != type) return YES; &#125; return NO;&#125; 跳转到APP的系统设置界面 12345678// 跳转到APP的系统设置界面if (switchView.isOn) &#123; NSURL * url = [NSURL URLWithString:UIApplicationOpenSettingsURLString]; if([[UIApplication sharedApplication] canOpenURL:url]) &#123; NSURL*url =[NSURL URLWithString:UIApplicationOpenSettingsURLString]; [[UIApplication sharedApplication] openURL:url]; &#125; &#125; 解决思路一开始对于这个功能一点也没有具体的解决思路，而且一直在程序里去思考这个问题，当用户跳到系统设置界面以后不管打开没有打开再次进入到程序中时没法知道是否打开也没法更新数据，之后突然想到当跳到系统设置界面的时候，程序已经进入了后台，自此有了我的解决方案。 当用户跳转到系统设置界面以后程序进入了后台，而当再次进入时程序由后台进入到前台复原状态，由此我们可以在applicationDidBecomeActive时发送一个通知。 12345678/** 当程序进入后台，再返回时注册发送通知*/- (void)applicationDidBecomeActive:(UIApplication *)application&#123; // 发送通知 [[NSNotificationCenter defaultCenter] postNotificationName:@\"pushNoti\" object:nil];&#125; 之后再需要更新数据的控制器里注册通知，当收到通知时重新判断是否打开了推送，然后更新数据。 1234567891011121314151617/*** 在viewDidLoad里注册通知*/- (void)viewDidLoad &#123; [super viewDidLoad]; // 是否打开通知使用NSUserDefaults存储 [[NSUserDefaults standardUserDefaults] setBool:[WEFileUtils isAllowedNotification] forKey:@\"push\"]; // 注册通知 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(updataPush) name:@\"pushNoti\" object:nil];&#125;/*** 收到通知以后重新取值存储然后更新数据*/- (void)updataPush&#123; [[NSUserDefaults standardUserDefaults] setBool:[WEFileUtils isAllowedNotification] forKey:@\"push\"]; [self.tableView reloadData];&#125; 结束语自此应用内打开推送功能集成成功，当然目前新闻推送目前还没有完美的方案去推送数据，同时这只是个人的一些思路和解决方案，有不足的地方还望提出来一起交流。","categories":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/categories/iOS/"}],"tags":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/tags/iOS/"},{"name":"推送","slug":"推送","permalink":"http://sanwcoder.github.io/tags/推送/"}]},{"title":"使用终端如何上传代码到GitHub","slug":"使用终端如何上传代码到GitHub","date":"2018-04-10T03:30:02.000Z","updated":"2018-04-10T03:55:47.000Z","comments":true,"path":"2018/04/10/使用终端如何上传代码到GitHub/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/使用终端如何上传代码到GitHub/","excerpt":"本篇文章简述下如何将新项目通过终端上传到github，并使用git进行版本开发","text":"本篇文章简述下如何将新项目通过终端上传到github，并使用git进行版本开发 1&gt; 配置SSH通道 查看是否存在隐藏文件.ssh 如果存在删除文件夹重新生成key /Users/《#用户名#&gt;/.ssh/id_rsa 生成SSHkey要求输入密码啥的一直回车 ssh-keygen -t rsa -C &quot;GitHub登录名&lt;#xxxxxxx@163.com#&gt;&quot; 成功以后 1pbcopy &lt; ~/.ssh/id_rsa.pub // 复制生成的key 到GitHub-&gt;setting-&gt;SSH and GPG keys 添加粘贴复制的key就算配置完成 添加SSH到GitHub 12ssh -T git@github.com // 执行完这条指令之后会输出 Are you sure you want to continue connecting (yes/no)? 输入 yes 回车回到github，刷新网页就可以看到钥匙旁的灰色小圆点变绿，就表明已经添加成功了。 2&gt; 本地创建本地git库123456mkdir LiteraryHeaven&lt;#git文件夹名称#&gt; // 创建git文件夹cd LiteraryHeaven // 跳转到相应文件夹git init // 创建git本地库，之后将你的文件放到文件夹内git status // 查看本地变了的文件，需要添加的问红色，需要提交的为绿色git add a.tex&lt;#要添加到git本地库的文件名称#&gt; // 或者使用 git add . 添加所有修改文件，git commit -m\"提交日志\" 3&gt; 创建远程git库 进入GitHub，创建一个远程库 进入新建的远程库以SSH方式查看远程库地址，进行复制4&gt; 关联本地库和远程库 123456789101112// 1.关联远程库git remote add origin git@github.com:xxxx/xxxx.git &lt;#远程库地址t#&gt; // 2.要把远程和本地两个不同的项目合并// 如果直接 pull 会报 fatal: refusing to merge unrelated histories 因此需要添加 --allow-unrelated-historiesgit pull origin master --allow-unrelated-histories // 3.推送本地分支到远程git push origin master // 如果报错，意思是push的本地库版本是在远程版本之后使用git remote origin -f // 强制推送git branch -a // 查看远程和本地所有分支git pull origin master // 拉取远程库到本地库git push origin :&lt;#branchName#&gt;[分支名] // 推送本地分支到远程分支 5&gt; 其他相关git操作请转至git终端操作语法","categories":[{"name":"github","slug":"github","permalink":"http://sanwcoder.github.io/categories/github/"}],"tags":[{"name":"git","slug":"git","permalink":"http://sanwcoder.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"http://sanwcoder.github.io/tags/github/"}]},{"title":"iOS代码编写规范","slug":"iOS代码编写规范","date":"2018-04-10T03:20:45.000Z","updated":"2018-04-10T03:30:59.000Z","comments":true,"path":"2018/04/10/iOS代码编写规范/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/iOS代码编写规范/","excerpt":"代码的规范对于开发而言是十分重要的同时也是衡量一名程序猿合格的指标，这篇文章写下关于自己对于iOS编写的习惯及一些理解。","text":"代码的规范对于开发而言是十分重要的同时也是衡量一名程序猿合格的指标，这篇文章写下关于自己对于iOS编写的习惯及一些理解。 一.注释规范1.创建类添加类注释1234/** * &lt;#空格#&gt;SanW--2017.5.3--公共参数 */@interface PTCommonParams : NSObject 2.属性注释12345/** *&lt;#空格#&gt;设备系统版本 */(/// &lt;#空格#&gt;设备系统版本)@property&lt;#空格#&gt; (nonatomic,copy)&lt;#空格#&gt;NSString&lt;#空格#&gt;*osVersion; 3.更改对方代码时打上注释1#warning mark&lt;#空格#&gt;- SanW--2017.5.3--解决数组越界奔溃（原因） 4.创建变量12 // &lt;#空格#&gt;是否退出（变量以下划线_开头）BOOL&lt;#空格#&gt;_isQuit; 二.命名规范（驼峰命名法） 1.It is good to be both clear and brief as possible, but clarity shouldn’t suffer because of brevity:2.In general, don’t abbreviate names of things. Spell them out, even if they’re long:3.However, a handful of abbreviations are truly common and have a long history of use. You can continue to use them; see Acceptable Abbreviations and Acronyms.4.Avoid ambiguity in API names, such as method names that could be interpreted in more than one way. 1.类，方法，属性，变量命名12345678// &lt;#空格#&gt;类命名一般添加个人/公司/应用程序大写字母作为前缀PTHoneController,PTUserModel,PTHeaderView// &lt;#空格#&gt;方法命名主要从 --要什么 -- 做什么-&lt;#空格#&gt;(NSString&lt;#空格#&gt;*)itemNamed:(NSString&lt;#空格#&gt;*)name -&lt;#空格#&gt;(NSString&lt;#空格#&gt;*)findItemWithName:(NSString&lt;#空格#&gt;*)name -&lt;#空格#&gt;(NSString&lt;#空格#&gt;*)itemAtIndex:(NSUInteger)index //&lt;#空格#&gt;变量名称以下划线开头_BOOL&lt;#空格#&gt;_isQuit; 2.枚举表示状态、选项定义的枚举类型名称应以 2~3 个大写字母开头，而这通常与项目设置的类文件前缀相同，跟随其后的命名应采用驼峰命名法则，命名应准确表述枚举表示的意义，枚举中各个值都应以定义的枚举类型开头，其后跟随各个枚举值对应的状态、选项或者状态码。123456789101112// 名称以类名前缀+表示的意义 值：枚举名+对应的状态、选项或者状态码typedef NS_ENUM(NSInteger,ReportHeaderType) &#123;ReportHeaderTypeAudio, //&lt;#空格#&gt;音频ReportHeaderTypeVideo //&lt;#空格#&gt;视频&#125;;typedef NS_OPTIONS(NSUInteger, UIViewAutoresizing) &#123;UIViewAutoresizingNone = 0,UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0,UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1,UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2,UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3&#125;; 3.常量最好以宏代替部分方法，常量用const去定义 1&gt; 使用宏预处理定义以k+代表意义定义，这样定义的常量无类型信息，且如果你在调试时想要查看 kRadius 的值却无从下手，因为在预处理阶段kRadius 就已经被替换了，不便于调试//&lt;#空格#&gt;圆角弧度#define kRadius 6 2&gt; 使用类型常量为常量带入类型信息12345678// &lt;#空格#&gt;通常以个人/公司/类名大写字母作为前缀+代表的意义+Const后缀const&lt;#空格#&gt;NSTimeInterval&lt;#空格#&gt;PTAnimationDurationConst&lt;#空格#&gt;=&lt;#空格#&gt;0.3;NSString&lt;#空格#&gt;*const&lt;#空格#&gt;UIApplicationLaunchOptionsLocalNotificationKey;// &lt;#空格#&gt;消息区分私信.hextern&lt;#空格#&gt;NSString&lt;#空格#&gt;*const&lt;#空格#&gt;MESSAGE_LIVE_TYPE;.mNSString&lt;#空格#&gt;*const&lt;#空格#&gt;MESSAGE_LIVE_TYPE&lt;#空格#&gt;=&lt;#空格#&gt;@\"直播间主播私信\"; 4.分类及其分类方法分类名称以个人/公司/类名大写字母作为前缀+系统类名+ Ex后缀，分类中的方法名以个人/公司/类名小写字母作为前缀，且以下划线连接前缀与方法名。123UIColor+PTColorEx.h// &lt;#空格#&gt;16进制颜色转换+&lt;#空格#&gt;(UIColor&lt;#空格#&gt;*)pt_colorWithHexString:(NSString&lt;#空格#&gt;*)hexString; 5.block和协议命名 Block 12// &lt;#空格#&gt;block表示的意义首字母大写 + Block后缀@property&lt;#空格#&gt;(nonatomic,copy)&lt;#空格#&gt;void&lt;#空格#&gt;(^ChooseClassfyBlock)(PTLiveClassfyModel&lt;#空格#&gt;*classfyInfo,UIButton&lt;#空格#&gt;*sender); 2.代理协议 12// &lt;#空格#&gt;使用protocol定义代理协议时类名+Delegate 后缀@protocol&lt;#空格#&gt;PTHomeViewDelegate&lt;#空格#&gt;&lt;NSObject&gt; 6.判断（switch/ if…..else）在项目中尽量减少if…else 的使用，使用switch便利，相对而言if条件判断，switch匹配","categories":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/categories/iOS/"}],"tags":[{"name":"code rule","slug":"code-rule","permalink":"http://sanwcoder.github.io/tags/code-rule/"}]},{"title":"git终端操作语法","slug":"git终端操作语法","date":"2018-04-10T03:12:29.000Z","updated":"2018-04-10T03:17:36.000Z","comments":true,"path":"2018/04/10/git终端操作语法/","link":"","permalink":"http://sanwcoder.github.io/2018/04/10/git终端操作语法/","excerpt":"git是一种分子式版本管理工具，git的操作有许多可视化工具如sourceTree等，但这篇文章主要写下如何使用git主评断语法来操作git","text":"git是一种分子式版本管理工具，git的操作有许多可视化工具如sourceTree等，但这篇文章主要写下如何使用git主评断语法来操作git 一.代码提交规范123456eg: &lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&lt;BLANK LINE&gt;&lt;body&gt;&lt;BLANK LINE&gt;g&lt;footer&gt; 1&gt; type 用于说明 commit 的类别，只允许使用下面7个标识。 docs: 仅文档更改 feat: 一个新功能 fix: 修复错误 perf: 改进性能的代码更改 refactor: 代码更改，既不修复错误也不添加功能 style: 不影响代码含义的变化（空白，格式化，缺少分号等） test: 添加缺失测试或更正现有测试 chore: 改变构建流程、或者增加依赖库、工具等 2&gt; scope 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。3&gt; subject是 commit 目的的简短描述，不超过50个字符。1234eg：feat: all middleware support async function and common functionfeat: all middleware support async function and common functiondocs: add quickstart.md 二.Git终端基本操作1&gt; 操作流程12345678910111213141516171819202122232425262728293031323334353637// 创建本地仓库并和远程仓库关联// 1.创建本地存放git的文件目录mkdir &lt;#gitTest#&gt;[目录名]// 2.进入到当前目录cd gitTest// 3.创建一个本地文件并编辑touch a.txtopen a.txt// 4.创建本地git仓库git init// 5.查看本地仓库文件变化（变红）git status// 6.将本地项目工作区的所有文件添加到暂存区git add .(第一次提交所有文件到本地暂存区)git add a.txt （有变化的文件添加到暂存区）// 6.再次查看本地仓库文件变化（变绿）git status// 7.将暂存区文件提交到本地仓库git commit -m \"测试\"// 8.再次查看本地仓库文件变化（显示没有变化）git status// 10.然后在相应的GitHub/GitLab上创建远程仓库// 11.创建完成以后配置相关用户信息git config --global user.name \"wenweiwei\"git config --global user.email \"wenweiwei@16lao.com\"// 12.将本地仓库与远程仓库关联git remote add origin &lt;#git@192.168.3.191:wenweiwei/GitTestProject.git#&gt;[远程仓库地址]// 12.1 修改关联远程库git remote set-url origin &lt;#git@118.89.225.146:16lao/ios.git&gt;[新远程仓库地址]// 12.2 删除当前关联的远程库git remote rm origin // 13.更新远程库到本地git pull origin master // 14.将本地仓库文件推送到远程仓库git push origin master// 15.查看远程仓库git remote -v 2&gt;.基本操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 1. 查看目前代码的修改状态:git status// 2. 查看文件修改内容git diff &lt;#a.txt#&gt;[文件名]// 3.删除文件git rm &lt;#a.txt#&gt;[文件名]// 4.添加修改文件到暂存文件git add &lt;#a.txt#&gt;git add &lt;#b.txt#&gt;// 5.提交已暂存的文件到本地仓库git commit -m \"添加文件\"// 6.同步远程仓库到本地仓库git pull origin master// 7.有冲突解决冲突后推送，没有直接推送到远程仓库git push origin master// 8.查看当前分支git branch (绿色标志为当前分支)git branch -a (查看远程分支，远程分支用红色表示，当前本地分支用绿色表示)// 9.创建分支git branch &lt;#branchName#&gt;[分支名]// 10.检出分支git checkout &lt;#branchName#&gt;[分支名]// 11.创建并切换到新分支git checkout -b &lt;#branchName#&gt;[分支名]// 12.合并分支git merge &lt;#branchName#&gt;[要合并到当前分支上的分支名]// 13.删除分支git branch -d &lt;#branchName#&gt;[分支名]git push --delete origin&lt;#branchName#&gt;[分支名](删除远程分支)// 如何切换远程分支 1.现在本地创建分支 2.更新远程分支到新建的本地分支// 14.推送远程分支git push origin :&lt;#branchName#&gt;[分支名]// 15.查看标签git tag// 16.创建标签git tag v1.0.0// 17.查看日志git log（提交Id，提交人，提交日期，提交msg）git log --pretty=oneline --abbrev-commit （提交简短Id，提交msg）// 18 .补打标签git tag v1.1.1 &lt;#6224937#&gt;[提交Id]// 19.查看标签信息git show &lt;#tagName#&gt;[标签名]// 20.删除标签git tag -d &lt;#tagName#&gt;[标签名]// 21.推送标签到远程git push origin &lt;#tagName#&gt;[标签名]// 22.推送所有本地标签到远程git push origin --tags// 23.删除远程标签git tag -d &lt;#tagName#&gt;[标签名] // 删除本地标签git push origin :refs/tags/&lt;#tagName#&gt;[标签名] // 删除远程标签// 24.查看远程taggit fetch origin tag &lt;#tagName#&gt;[标签名]// 25.克隆远程仓库(先进入到需要克隆岛本地目录)git clone &lt;#git@192.168.3.191:wenweiwei/GitTestProject.git#&gt;[远程仓库地址]","categories":[{"name":"git","slug":"git","permalink":"http://sanwcoder.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://sanwcoder.github.io/tags/git/"}]},{"title":"load跟initalize区别","slug":"load跟initalize区别","date":"2018-04-09T03:43:42.000Z","updated":"2018-04-09T07:23:55.000Z","comments":true,"path":"2018/04/09/load跟initalize区别/","link":"","permalink":"http://sanwcoder.github.io/2018/04/09/load跟initalize区别/","excerpt":"initialize 和 load 是 NSObject 的两个特殊类方法，在面试过程中很有可能会问到同时在工作中我们也可以利用其相应的特性做一些操作。","text":"initialize 和 load 是 NSObject 的两个特殊类方法，在面试过程中很有可能会问到同时在工作中我们也可以利用其相应的特性做一些操作。 一. load1&gt; 基本区别 load是在程序运行时出发（加入编译文件Compile Sources），且仅调用一次，无需手动调用。 load 方法不遵从继承规则，如果类本身没有实现load方法，那么系统就不会调用，谁实现就会调用谁的load方法。 尽可能的精简load方法，因为整个应用程序在执行load方法时会阻塞，即，程序会阻塞直到所有类的load方法执行完毕，才会继续 load 方法中最常用的就是方法交换method swizzling 2&gt; 实例分析开发文档说明： 创建类及其load方法 1234567891011121314151617// People.m+ (void)load&#123;NSLog(@\"class == People,method == load\");&#125;// Student.m 继承自People+ (void)load&#123;NSLog(@\"class == Student,method == load\");&#125;// Teacher.m 继承自People+ (void)load&#123;NSLog(@\"class == Teacher,method == load\");&#125;// People+Ext.m People的分类+ (void)load&#123;NSLog(@\"class == People (Ext),method == load\");&#125; // method swizzling 实现方法交换+ (void)load&#123; Method personMethod = class_getInstanceMethod([Person class], NSSelectorFromString(@\"personSay\")); Method studentMethod = class_getInstanceMethod([Student class], NSSelectorFromString(@\"studentSay\")); method_exchangeImplementations(personMethod, studentMethod); &#125; 运行结果 二. initalize1&gt; 基本区别 当某个类第一次收到消息的时候触发,且只调用一次，无需手动调用。 父类实现initalize，子类没有实现，调用子类会同时触发父类两次 父类实现initalize，子类也实现，调用子类会先触发父类再触发子类 父类实现initalize，父类分类也实现，分类方法会覆盖父类方法，调用的是分类方法 2&gt; 实例分析开发文档说明： 创建类及其initialize方法 123456// People.m+ (void)initialize&#123;NSLog(@\"class == %@,method == initialize\",NSStringFromClass([self class]));&#125;// Student.m 继承自People+ (void)initialize&#123;NSLog(@\"class == %@,method == initialize\",NSStringFromClass([self class]));&#125;// People+Ext.m People的分类+ (void)initialize&#123;NSLog(@\"class categary == %@,method == initialize\",NSStringFromClass([self class]));&#125; 运行结果","categories":[{"name":"iOS","slug":"iOS","permalink":"http://sanwcoder.github.io/categories/iOS/"}],"tags":[{"name":"Object-C","slug":"Object-C","permalink":"http://sanwcoder.github.io/tags/Object-C/"}]},{"title":"如何使用hexo搭建个人博客并部署到github","slug":"如何使用hexo搭建个人博客并部署到github","date":"2018-04-04T03:47:54.000Z","updated":"2018-04-10T03:11:09.000Z","comments":true,"path":"2018/04/04/如何使用hexo搭建个人博客并部署到github/","link":"","permalink":"http://sanwcoder.github.io/2018/04/04/如何使用hexo搭建个人博客并部署到github/","excerpt":"使用Hexo搭建个人博客","text":"使用Hexo搭建个人博客 安装&amp;搭建安装Node.js 到node.js官网下载相应版本按照提示安装 使用Homebrow安装 123456789// 1. 安装HomeBrow~ ruby -e \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)\"// 2. 安装node~ brew install node// 3. 安装完成后测试是否安装成功// 3.1 查看node版本~ node -version// 3.2 查看npm版本~ npm -version 安装Hexo1~ npm install -g hexo-cli 安装git1~ brew install git 配置GitHub在你的Github下创建新仓库并将仓库名命名为 GitHub名.github.io这样命名后GitHub会自动 启用 GitHub Pages并将你的博客地址设置为 https://GitHub名.github.io/ 初步搭建&amp;本地测试 使用Hexo创建博客 123~ hexo init &lt;folder&gt;~ cd &lt;folder&gt;~ npm install 创建完成后在相应的文件=夹中会有如下显示 12345678.├── _config.yml // 必要的配置文件，如博客名├── package.json // 应用程序的信息├── scaffolds // 模版文件夹,post.md,drafts.md├── source // 资源文件夹| ├── _drafts| └── _posts└── themes // 主题文件夹 本地测试 1234567// 清除缓存文件~ hexo clean // 生成静态文件~ hexo generate/g// 启动服务器~ hexo server// 服务器启动以后再浏览器中打开 http://localhost:4000/即可查看博客 自定义（以Icarus主题为例） 下载相应的主题主题 1~ git clone https://github.com/ppoffice/hexo-theme-icarus.git 配置_config.yml 1234567891011121314151617title: SanW // 标题subtitle: // 福标题description: // 描述keywords: ios // 搜索关键字author: // 作者language: zh-CN // Hexo支持国际化，设置相应语言在/themes/icarus/languages 下url: http://sanwcoder.github.io // 设置成你的博客地址// 文件root，如果直接在当前文件夹下设置为/，切记要设置正确，设置错误会加载不出来样式root: / permalink: :year/:month/:day/:title/permalink_defaults:// 设置你下载的主题，将你下载的主题放到themes文件夹下，并在这儿设置为相应的主题theme: icarus// 部署到githubdeploy: type: git // 类型为git repo: // 仓库的完整地址，在部署时会部署到git库的master分支上 在/themes/icarus/_config.yml位置下更改相应主题的_config.yml 12345678910111213141516171819202122232425262728// 菜单栏menu: Home: . Archives: archives Categories: categories Tags: tags About: about# Customizecustomize: // 网站图标 logo: enabled: true width: 40 height: 40 url: images/icon.jpg profile: enabled: true avatar: css/images/icon.jpg author: // 网站作者 author_title: // 作者简介 location: // 位置 FengTai, China follow: // 作者github地址 social_links: // 其他社交链接 github: Weibo: email: social_link_tooltip: true 部署到github 123456// 清除缓存文件~ hexo clean // 生成文件~ hexo g// 部署到GitHub~ hexo d 访问https://GitHub名.github.io 添加搜索 在/themes/icarus/_config.yml中打开搜索 1insight: true // 打开内部搜索 安装内部搜索支持 1~ npm install -S hexo-generator-json-content 重新部署/ 启动服务 技巧部署到github以后hexo只是把相应生成blog的静态文件上传到了相应分支上而非源文件，我们要在其他电脑重新部署时无法使用源文件解决这个问题可以从两方面： 新建一个git仓库存放源文件 在当前仓库创建一个新分支存放源文件 未完待续…","categories":[{"name":"blog","slug":"blog","permalink":"http://sanwcoder.github.io/categories/blog/"}],"tags":[{"name":"github","slug":"github","permalink":"http://sanwcoder.github.io/tags/github/"},{"name":"blog","slug":"blog","permalink":"http://sanwcoder.github.io/tags/blog/"}]}]}