---
title: 收到推送时程序内的处理方案
comments: true
date: 2016-06-01 12:27:17
tags:
 - iOS
 - 推送
categories:
 - iOS
photos:
thumbnail:
---

在应用中经常会添加推送，在我们的项目中也用到了推送，推送添加的是友盟的第三方推送方案，接入友盟的SDK只要按照步骤，接进来也十分简单，完全可以收到推送数据，但问题是在收到推送数据时如何去处理收到的信息以及如何跳转相应的界面？这是我这篇文章主要介绍的。

<!-- more -->

## 解决思路
iOS提供收到推送时的处理方法，但是收到推送应该从几个方面来考虑这才是关键的点，对于一个刚接触的人来说也是不知所措，之后再网上查找零零碎碎的找到了一些突破点，才完成了对于收到推送的处理方式，主要从以下两个方面来考虑。

1. 当程序没有死掉即在在前台或者后台时

```objc
/**
 *  收到推送时会在AppDelegate的didReceiveRemoteNotification中响应事件
 */
- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo
{
       // 这里做收到推送时的处理userInfo为收到的数据
}
```

+ 程序在运行在前台即处于UIApplicationStateActive状态

![处于UIApplicationStateActive状态时的处理](/gallery/APNS-001.jpg)

在UIApplicationStateActive时只需要定义一个alertView来处理，在代理方法里跳转相应的详情，当然这个跳转必须要有navigationController来跳转并且navigationController要作为一个属性。

```objc
- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo
{
    // 保存推送数据
     self.userInfos = userInfo;
      // 定制自定义的弹框
        if([UIApplication sharedApplication].applicationState == UIApplicationStateActive)
        {
            UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@"有新的要闻推荐哦~"
            message:userInfo[@"aps"][@"alert"]
            delegate:self
            cancelButtonTitle:@"取消"
            otherButtonTitles:@"立即前往", nil];
            [alertView show];
        }
}
// iOS 10 会走新 API, iOS 10 以前会走到老 API
#if __IPHONE_OS_VERSION_MAX_ALLOWED >= __IPHONE_10_0
// App 用户点击通知的回调
// 无论本地推送还是远程推送都会走这个回调
- (void)userNotificationCenter:(UNUserNotificationCenter *)center didReceiveNotificationResponse:(UNNotificationResponse *)response withCompletionHandler:(void(^)())completionHandler {
    
    WELog(@"[XGDemo] click notification");
    [XGPush handleReceiveNotification:response.notification.request.content.userInfo
                      successCallback:^{
                          WELog(@"[XGDemo] Handle receive success");
                      } errorCallback:^{
                          WELog(@"[XGDemo] Handle receive error");
                      }];
    // 处理推送
    [self receivePushInfo:response.notification.request.content.userInfo];
    completionHandler();
}
```
// App 在前台弹通知需要调用这个接口
- (void)userNotificationCenter:(UNUserNotificationCenter *)center willPresentNotification:(UNNotification *)notification withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler {
    
    WELog(@"[XGDemo] click notification");
    [XGPush handleReceiveNotification:notification.request.content.userInfo
                      successCallback:^{
                          WELog(@"[XGDemo] Handle receive success");
                      } errorCallback:^{
                          WELog(@"[XGDemo] Handle receive error");
                      }];
    // 处理推送
    [self receivePushInfo:notification.request.content.userInfo];
    completionHandler(UNNotificationPresentationOptionBadge | UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert);
}

alerView的代理方法里执行跳转详情
 // pragma mark -跳转到推送详情页
- (void)notificationDetailVc {
    INHelpProtrolViewController *help = [[INHelpProtrolViewController alloc]init];
    help.urlString = self.userInfos[@"src_link"];
    [self.mainNavigationController pushViewController:help animated:YES];
}

+ 程序在运行在后台但没死掉即处于UIApplicationStateInactive状态时

![处于UIApplicationStateInactive状态时](/gallery/APNS-002.jpg)

当你点击通知栏上的通知时程序程序会触发didReceiveRemoteNotification方法

```objc
- (void)application:(UIApplication *)application didReceiveRemoteNotification:(NSDictionary *)userInfo
{

     if ([UIApplication sharedApplication].applicationState == UIApplicationStateInactive){
            // 跳转详情页面
                INHelpProtrolViewController *help = [[INHelpProtrolViewController alloc]init];
    help.urlString = self.userInfos[@"src_link"];
    [self.mainNavigationController pushViewController:help animated:YES];
        }
}
```

2. 当程序完全死掉时

![当程序完全死掉时](/gallery/APNS-003.jpg)

```objc
// 程序启动时
- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
/// 上面创建window，navgationController等操作，创建完成后判断是否是由推送打开之后跳转
#pragma mark -判断是否由推送打开
    // 判断是否是通过推送打开app
    NSDictionary *userInfos = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey];
    if (userInfos) {
        // 保存数据
        self.userInfos = userInfos;
        // 跳转详情
           INHelpProtrolViewController *help = [[INHelpProtrolViewController alloc]init];
    help.urlString = self.userInfos[@"src_link"];
    [self.mainNavigationController pushViewController:help animated:YES];
    }
    return YES;
}
```

